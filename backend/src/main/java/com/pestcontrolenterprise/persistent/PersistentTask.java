package com.pestcontrolenterprise.persistent;

import com.google.common.base.Objects;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.pestcontrolenterprise.ApplicationContext;
import com.pestcontrolenterprise.api.*;
import com.pestcontrolenterprise.util.Segment;
import org.hibernate.annotations.Type;

import javax.persistence.*;
import java.io.Serializable;
import java.time.Instant;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.concurrent.CopyOnWriteArrayList;

import static com.pestcontrolenterprise.api.Admin.AdminSession;
import static com.pestcontrolenterprise.api.InvalidStateException.inactiveSession;
import static com.pestcontrolenterprise.api.InvalidStateException.notEnoughAccess;
import static com.pestcontrolenterprise.api.ReadonlyTask.DataChangeTaskHistoryEntry.TaskField;
import static com.pestcontrolenterprise.api.ReadonlyWorker.WorkerSession;
import static com.pestcontrolenterprise.api.User.UserSession;
import static java.util.Collections.emptyMap;

/**
 * @author myzone
 * @date 4/28/14
 */
@Entity
public class PersistentTask extends PersistentObject implements Task {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    protected final long id = autoGenerated();

    @Column
    protected volatile Status status;

    @ManyToOne(targetEntity = PersistentWorker.class, cascade = CascadeType.ALL)
    protected volatile ReadonlyWorker executor;

    @Type(type = "serializable")
    @Column(length = 8192)
    protected volatile ImmutableSet<Segment<Instant>> availabilityTime;

    @ManyToOne(targetEntity = PersistentCustomer.class, cascade = CascadeType.ALL)
    protected volatile ReadonlyCustomer customer;

    @ManyToOne(targetEntity = PersistentPestType.class, cascade = CascadeType.ALL)
    protected volatile PestType pestType;

    @Column
    protected volatile String problemDescription;

    @ManyToMany(targetEntity = SimpleTaskHistoryEntry.class)
    protected volatile List<TaskHistoryEntry> taskHistory;

    @Deprecated
    protected PersistentTask() {
        super();
    }

    public PersistentTask(
            ApplicationContext applicationContext,
            AdminSession causer,
            Status status,
            Optional<? extends ReadonlyWorker> executor,
            ImmutableSet<Segment<Instant>>availabilityTime,
            ReadonlyCustomer customer,
            PestType pestType,
            String problemDescription,
            String comment
    ) throws InvalidStateException {
        super(applicationContext);

        if (!causer.isStillActive(getApplicationContext().getClock()))
            throw inactiveSession();

        this.status = status;
        this.executor = executor.orElse(null);
        this.availabilityTime = availabilityTime;
        this.customer = customer;
        this.pestType = pestType;
        this.problemDescription = problemDescription;
        this.taskHistory = new CopyOnWriteArrayList<>();

        persistHistoryEntry(new SimpleTaskHistoryEntry(applicationContext, getApplicationContext().getClock().instant(), causer.getOwner(), comment));

        save();
    }

    @Override
    public long getId() {
        return id;
    }

    @Override
    public Status getStatus() {
        try (QuiteAutoCloseable lock = readLock()) {
            return status;
        }
    }

    @Override
    public Optional<ReadonlyWorker> getExecutor() {
        try (QuiteAutoCloseable lock = readLock()) {
            return Optional.<ReadonlyWorker>ofNullable(executor);
        }
    }

    @Override
    public ImmutableSet<Segment<Instant>> getAvailabilityTime() {
        try (QuiteAutoCloseable lock = readLock()) {
            return availabilityTime;
        }
    }

    @Override
    public ReadonlyCustomer getCustomer() {
        try (QuiteAutoCloseable lock = readLock()) {
            return customer;
        }
    }

    @Override
    public PestType getPestType() {
        try (QuiteAutoCloseable lock = readLock()) {
            return pestType;
        }
    }

    @Override
    public String getProblemDescription() {
        try (QuiteAutoCloseable lock = readLock()) {
            return problemDescription;
        }
    }

    @Override
    public ImmutableList<TaskHistoryEntry> getTaskHistory() {
        try (QuiteAutoCloseable lock = readLock()) {
            return ImmutableList.copyOf(taskHistory);
        }
    }

    @Override
    public void setStatus(UserSession causerSession, Status status, String comment) throws InvalidStateException {
        try (QuiteAutoCloseable lock = writeLock()) {
            if (!causerSession.isStillActive(getApplicationContext().getClock()))
                throw inactiveSession();
            if (!isExecutorsSession(causerSession) && !isAdminSession(causerSession))
                throw notEnoughAccess("todo this message"); // @todo this message

            persistHistoryEntry(new SingleChangeTaskTaskHistory(
                    getApplicationContext(),
                    getApplicationContext().getClock().instant(),
                    causerSession.getOwner(),
                    comment,
                    TaskField.status,
                    new PersistentChange<>(this.status.name(), status.name())
            ));

            this.status = status;

            update();
        }
    }

    @Override
    public void setExecutor(UserSession causerSession, Optional<? extends ReadonlyWorker> executor, String comment) throws InvalidStateException {
        try (QuiteAutoCloseable lock = writeLock()) {
            if (!causerSession.isStillActive(getApplicationContext().getClock()))
                throw inactiveSession();
            if ((!isExecutorsSession(causerSession) || !executor.isPresent()) && !isAdminSession(causerSession))
                throw notEnoughAccess("todo this message"); // @todo this message

            persistHistoryEntry(new SingleChangeTaskTaskHistory(
                    getApplicationContext(),
                    getApplicationContext().getClock().instant(),
                    causerSession.getOwner(),
                    comment,
                    TaskField.executor,
                    new PersistentChange<String>(
                            Optional.ofNullable(this.executor)
                                    .map(ReadonlyWorker::getLogin)
                                    .orElse(null) ,
                            executor.map(ReadonlyWorker::getLogin)
                                    .orElse(null)
                    )
            ));

            this.executor = executor.orElse(null);

            update();
        }
    }

    @Override
    public void setAvailabilityTime(UserSession causerSession, ImmutableSet<Segment<Instant>> availabilityTime, String comment) throws InvalidStateException {
        try (QuiteAutoCloseable lock = writeLock()) {
            if (!causerSession.isStillActive(getApplicationContext().getClock()))
                throw inactiveSession();
            if (!isAdminSession(causerSession))
                throw notEnoughAccess("todo this message"); // @todo this message

            persistHistoryEntry(new SingleChangeTaskTaskHistory(
                    getApplicationContext(),
                    getApplicationContext().getClock().instant(),
                    causerSession.getOwner(),
                    comment,
                    TaskField.availabilityTime,
                    new PersistentChange<>(String.valueOf(this.availabilityTime), String.valueOf(availabilityTime))
            ));

            this.availabilityTime = availabilityTime;

            update();
        }
    }

    @Override
    public void setCustomer(UserSession causerSession, ReadonlyCustomer customer, String comment) throws InvalidStateException {
        try (QuiteAutoCloseable lock = writeLock()) {
            if (!causerSession.isStillActive(getApplicationContext().getClock()))
                throw inactiveSession();
            if (!isAdminSession(causerSession))
                throw notEnoughAccess("todo this message"); // @todo this message

            persistHistoryEntry(new SingleChangeTaskTaskHistory(
                    getApplicationContext(),
                    getApplicationContext().getClock().instant(),
                    causerSession.getOwner(),
                    comment,
                    TaskField.customer,
                    new PersistentChange<>(this.customer.getName(), customer.getName())
            ));

            this.customer = customer;

            update();
        }
    }

    @Override
    public void setPestType(UserSession causerSession, PestType pestType, String comment) throws InvalidStateException {
        try (QuiteAutoCloseable lock = writeLock()) {
            if (!causerSession.isStillActive(getApplicationContext().getClock()))
                throw inactiveSession();
            if (!isAdminSession(causerSession))
                throw notEnoughAccess("todo this message"); // @todo this message;

            persistHistoryEntry(new SingleChangeTaskTaskHistory(
                    getApplicationContext(),
                    getApplicationContext().getClock().instant(),
                    causerSession.getOwner(),
                    comment,
                    TaskField.pestType,
                    new PersistentChange<>(this.pestType.getName(), pestType.getName())
            ));

            this.pestType = pestType;

            update();
        }
    }

    @Override
    public void setProblemDescription(UserSession causerSession, String problemDescription, String comment) throws InvalidStateException {
        try (QuiteAutoCloseable lock = writeLock()) {
            if (!causerSession.isStillActive(getApplicationContext().getClock()))
                throw inactiveSession();
            if (!isAdminSession(causerSession))
                throw notEnoughAccess("todo this message"); // @todo this message;

            persistHistoryEntry(new SingleChangeTaskTaskHistory(
                    getApplicationContext(),
                    getApplicationContext().getClock().instant(),
                    causerSession.getOwner(),
                    comment,
                    TaskField.problemDescription,
                    new PersistentChange<>(this.problemDescription, problemDescription)
            ));

            this.problemDescription = problemDescription;

            update();
        }
    }

    protected void persistHistoryEntry(TaskHistoryEntry taskHistoryEntry) {
        try (QuiteAutoCloseable lock = writeLock()) {
            TaskHistoryEntry peek = !taskHistory.isEmpty() ? taskHistory.get(taskHistory.size() - 1) : null;

            if (peek != null) {
                if (peek instanceof MergeableTaskHistoryEntry) {
                    if (((MergeableTaskHistoryEntry) peek).tryMerge(taskHistoryEntry)) {
                        return;
                    }
                } else {
                    MergeableTaskHistoryEntry mergeable = new MergeableTaskHistoryEntry(getApplicationContext(), peek.getInstant(), peek.getCauser(), peek.getComment());

                    if (mergeable.tryMerge(peek) && mergeable.tryMerge(taskHistoryEntry)) {
                        taskHistory.remove(taskHistory.size() - 1);
                        taskHistoryEntry = mergeable;
                    }
                }
            }

            taskHistory.add(taskHistoryEntry);
        }
    }

    protected boolean isAdminSession(UserSession userSession) {
        return userSession instanceof AdminSession;
    }

    protected boolean isExecutorsSession(UserSession userSession) {
        try (QuiteAutoCloseable lock = readLock()) {
            return userSession instanceof WorkerSession && userSession.getOwner().equals(executor);
        }
    }

    @Override
    public boolean equals(Object o) {
        try (QuiteAutoCloseable lock = readLock()) {
            if (this == o) return true;
            if (!(o instanceof PersistentTask)) return false;

            PersistentTask that = (PersistentTask) o;

            try (QuiteAutoCloseable lock1 = that.readLock()) {
                if (id != that.id) return false;
                if (!availabilityTime.equals(that.availabilityTime)) return false;
                if (!customer.equals(that.customer)) return false;
                if (!executor.equals(that.executor)) return false;
                if (!pestType.equals(that.pestType)) return false;
                if (!problemDescription.equals(that.problemDescription)) return false;
                if (status != that.status) return false;
                if (!taskHistory.equals(that.taskHistory)) return false;
            }

            return true;
        }
    }

    @Override
    public int hashCode() {
        try (QuiteAutoCloseable lock = readLock()) {
            int result = (int) (id ^ (id >>> 32));
            result = 31 * result + status.hashCode();
            result = 31 * result + executor.hashCode();
            result = 31 * result + availabilityTime.hashCode();
            result = 31 * result + customer.hashCode();
            result = 31 * result + pestType.hashCode();
            result = 31 * result + problemDescription.hashCode();
            result = 31 * result + taskHistory.hashCode();
            return result;
        }
    }

    @Override
    public String toString() {
        try (QuiteAutoCloseable lock = readLock()) {
            return Objects.toStringHelper(this)
                    .add("status", status)
                    .add("executor", executor)
                    .add("availabilityTime", availabilityTime)
                    .add("customer", customer)
                    .add("pestType", pestType)
                    .add("problemDescription", problemDescription)
                    .add("taskHistory", taskHistory)
                    .toString();
        }
    }

    @Entity
    @Inheritance(strategy = InheritanceType.SINGLE_TABLE)
    @DiscriminatorColumn(length = 100)
    public static class SimpleTaskHistoryEntry extends PersistentObject implements TaskHistoryEntry {

        @Id
        @GeneratedValue(strategy = GenerationType.AUTO)
        protected final long id = autoGenerated();

        @Column
        protected final Instant instant;

        @ManyToOne(targetEntity = PersistentUser.class)
        protected final User causer;

        @Column(length = 1024)
        protected final String comment;

        @Deprecated
        protected SimpleTaskHistoryEntry() {
            super();

            instant = null;
            causer = null;
            comment = null;
        }

        public SimpleTaskHistoryEntry(ApplicationContext applicationContext, Instant instant, User causer, String comment) {
            super(applicationContext);

            this.instant = instant;
            this.causer = causer;
            this.comment = comment;

            save();
        }

        @Override
        public Instant getInstant() {
            return instant;
        }

        @Override
        public User getCauser() {
            return causer;
        }

        @Override
        public String getComment() {
            return comment;
        }

        @Override
        public String toString() {
            return toStringHelper().toString();
        }

        protected Objects.ToStringHelper toStringHelper() {
            return Objects.toStringHelper(this)
                    .add("instant", instant)
                    .add("causer", causer)
                    .add("comment", comment);
        }

    }

    @Entity
    public static class SingleChangeTaskTaskHistory extends SimpleTaskHistoryEntry implements DataChangeTaskHistoryEntry {

        @Type(type = "serializable")
        @Column(length = 1024)
        protected final ImmutableMap<TaskField, Change<String>> changes;

        protected SingleChangeTaskTaskHistory() {
            super();

            changes = null;
        }

        public SingleChangeTaskTaskHistory(ApplicationContext applicationContext, Instant instant, User causer, String comment, TaskField field, Change<String> change) {
            super(applicationContext, instant, causer, comment);

            this.changes = ImmutableMap.of(field, change);

            save();
        }

        @Override
        public ImmutableMap<TaskField, Change<String>> getChanges() {
            return changes;
        }

    }

    @Entity
    public static class MergeableTaskHistoryEntry extends SimpleTaskHistoryEntry implements DataChangeTaskHistoryEntry {

        @Type(type = "serializable")
        @Column(length = 8192)
        protected volatile Map<TaskField, Change<String>> changes;

        protected MergeableTaskHistoryEntry() {
            super();
        }

        public MergeableTaskHistoryEntry(ApplicationContext applicationContext, Instant instant, User causer, String comment) {
            super(applicationContext, instant, causer, comment);

            changes = ImmutableMap.of();

            save();
        }

        public boolean tryMerge(TaskHistoryEntry taskHistoryEntry) {
            try (QuiteAutoCloseable lock = writeLock()) {
                Map<TaskField, Change<String>> oldChanges = changes;
                Map<TaskField, Change<String>> addingChanges = getChanges(taskHistoryEntry);

                if (causer.equals(taskHistoryEntry.getCauser())
                        && comment.equals(taskHistoryEntry.getComment())
                        && addingChanges
                        .entrySet()
                        .stream()
                        .map(entry -> {
                            Change<?> objects = oldChanges.get(entry.getKey());

                            return objects == null || objects.getOld().equals(entry.getValue().getNew());
                        })
                        .reduce(true, Boolean::logicalAnd)) {

                    Map<TaskField, Change<String>> changesBuilder = new HashMap<>();
                    changesBuilder.putAll(oldChanges);
                    changesBuilder.putAll(addingChanges);
                    changes = ImmutableMap.copyOf(changesBuilder);

                    return true;
                } else {
                    return false;
                }
            }
        }

        @Override
        public ImmutableMap<TaskField, Change<String>> getChanges() {
            try (QuiteAutoCloseable lock = readLock()) {
                return ImmutableMap.copyOf(changes);
            }
        }

        protected Objects.ToStringHelper toStringHelper() {
            try (QuiteAutoCloseable lock = readLock()) {
                return super.toStringHelper()
                        .add("changes", changes);
            }
        }

        protected Map<TaskField, Change<String>> getChanges(TaskHistoryEntry taskHistoryEntry) {
            return taskHistoryEntry instanceof DataChangeTaskHistoryEntry
                    ? ((DataChangeTaskHistoryEntry) taskHistoryEntry).getChanges()
                    : emptyMap();
        }

    }

    public static class PersistentChange<T extends Serializable> implements DataChangeTaskHistoryEntry.Change<T>, Serializable {

        private final T oldValue;
        private final T newValue;

        public PersistentChange(T oldValue, T newValue) {
            this.oldValue = oldValue;
            this.newValue = newValue;
        }

        @Override
        public T getOld() {
            return oldValue;
        }

        @Override
        public T getNew() {
            return newValue;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;

            PersistentChange that = (PersistentChange) o;

            if (newValue != null ? !newValue.equals(that.newValue) : that.newValue != null) return false;
            if (oldValue != null ? !oldValue.equals(that.oldValue) : that.oldValue != null) return false;

            return true;
        }

        @Override
        public int hashCode() {
            int result = oldValue != null ? oldValue.hashCode() : 0;
            result = 31 * result + (newValue != null ? newValue.hashCode() : 0);
            return result;
        }

        @Override
        public String toString() {
            return Objects.toStringHelper(this)
                    .add("oldValue", oldValue)
                    .add("newValue", newValue)
                    .toString();
        }

    }

}
